"use strict";(self.webpackChunkreact_native_reanimated_docs=self.webpackChunkreact_native_reanimated_docs||[]).push([[2671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1405:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={id:"measure",title:"measure",sidebar_label:"measure"},o=void 0,s={unversionedId:"api/nativeMethods/measure",id:"version-2.3.x/api/nativeMethods/measure",title:"measure",description:"Determines the location on screen, width, and height of the given view. Note that these measurements are not available until after the rendering has been completed in native. If you need the measurements as soon as possible, consider using onLayout instead.",source:"@site/versioned_docs/version-2.3.x/api/nativeMethods/measure.md",sourceDirName:"api/nativeMethods",slug:"/api/nativeMethods/measure",permalink:"/react-native-reanimated/docs/2.3.x/api/nativeMethods/measure",draft:!1,tags:[],version:"2.3.x",frontMatter:{id:"measure",title:"measure",sidebar_label:"measure"},sidebar:"version-2.3.x/docs",previous:{title:"Layout Transitions",permalink:"/react-native-reanimated/docs/2.3.x/api/LayoutAnimations/layoutTransitions"},next:{title:"scrollTo",permalink:"/react-native-reanimated/docs/2.3.x/api/nativeMethods/scrollTo"}},l={},u=[{value:"Arguments",id:"arguments",level:3},{value:"animatedRef",id:"animatedref",level:4},{value:"Returns",id:"returns",level:3},{value:"Example",id:"example",level:3},{value:"Note",id:"note",level:3}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Determines the location on screen, width, and height of the given view. Note that these measurements are not available until after the rendering has been completed in native. If you need the measurements as soon as possible, consider using ",(0,r.kt)("a",{parentName:"p",href:"https://reactnative.dev/docs/view#onlayout"},(0,r.kt)("inlineCode",{parentName:"a"},"onLayout"))," instead."),(0,r.kt)("p",null,"This function is implemented on native platforms only. On web, it's sufficient to use a standard version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"measure")," which is available on most of the default components provided by React Native (it's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/65975dd28de0a7b8b8c4eef6479bf7eee5fcfb93/Libraries/Renderer/shims/ReactNativeTypes.js#L105"},"here"),"). In such a case it should be invoked in the following way (note it's asynchronous so if you want to make it synchronous you should use ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const aref = useAnimatedRef();\nnew Promise((resolve, reject) => {\n  if (aref && aref.current) {\n    aref.current.measure((x, y, width, height, pageX, pageY) => {\n      resolve({ x, y, width, height, pageX, pageY });\n    });\n  } else {\n    reject(new Error('measure: animated ref not ready'));\n  }\n});\n")),(0,r.kt)("h3",{id:"arguments"},"Arguments"),(0,r.kt)("h4",{id:"animatedref"},"animatedRef"),(0,r.kt)("p",null,"The product of ",(0,r.kt)("a",{parentName:"p",href:"../hooks/useAnimatedRef"},(0,r.kt)("inlineCode",{parentName:"a"},"useAnimatedRef"))," which is Reanimated's extension of a standard React ref (delivers the view tag on the UI thread)."),(0,r.kt)("h3",{id:"returns"},"Returns"),(0,r.kt)("p",null,"Object which contains following fields"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"y")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"width")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"height")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pageX")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pageY"))),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const Comp = () => {\n  const aref = useAnimatedRef();\n\n  useDerivedValue(() => {\n    const measured = measure(aref);\n    // ...\n  });\n\n  return <View ref={aref} />;\n};\n")),(0,r.kt)("h3",{id:"note"},"Note"),(0,r.kt)("p",null,"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"measure()")," only on rendered components. A good practice is to wrap the function call with a ",(0,r.kt)("inlineCode",{parentName:"p"},"try{} catch{}")," block if there is a risk of calling the function on an item which is not rendered, for example: an invisible off screen item from FlatList."))}p.isMDXComponent=!0}}]);